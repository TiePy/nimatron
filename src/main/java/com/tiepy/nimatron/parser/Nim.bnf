/*
 * This file is based on example provided by the IntelliJ Platform SDK DevGuide.
 * Copyright 2000-2020 JetBrains s.r.o. and other contributors.
 * Use of original example source code is governed by the Apache 2.0 license.
 *
 * Copyright 2020 TiePy Ltd. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This file is part of Nimatron, a Nim plug-in for IDEA platform IDEs.
 *
 * Nimatron is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.  TiePy Ltd designates this
 * particular file as subject to the "Classpath" exception as provided
 * by TiePy Ltd in the LICENSE file that accompanied this code.
 *
 * Nimatron is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Nimatron.  If not, see <https://www.gnu.org/licenses/>.
 *
 * Please contact TiePy Ltd, 19 Lyall Way, Laurencekirk, AB30 1FU, UK
 * or visit www.tiepy.com if you need additional information or have any
 * questions.
 */

{
  parserClass="com.tiepy.nimatron.parser.NimParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Nim"
  psiImplClassSuffix="Impl"
  psiPackage="com.tiepy.nimatron.parser"
  psiImplPackage="com.tiepy.nimatron.parser.impl"

  elementTypeHolderClass="com.tiepy.nimatron.parser.NimTypes"
  elementTypeClass="com.tiepy.nimatron.psi.NimElementType"
  tokenTypeClass="com.tiepy.nimatron.psi.NimTokenType"

  tokens = [
    BRACKET="BRACKET"
    SEMICOLON="C_SEMICOLON"
    COMMA="C_COMMA"
    GRAVE_ACCENT="C_GRAVE_ACCENT"
  ]

  psiImplUtilClass="com.tiepy.nimatron.parser.impl.NimPsiImplUtil"
}

module ::= IND_EQ* (stmt ((';'|IND_EQ) stmt)*)? ';'? IND_EQ*
operator ::= OP0|OP1|OP2|OP3|OP4|OP5|OP6|OP7|OP8|OP9|'from'|'static'|'..'
private meta optInd ::= <<RULE>> | (IND_GT <<RULE>> IND_LT)
simpleExpr ::= arrowExpr (OP0 <<optInd arrowExpr>>)* pragma?
arrowExpr ::= assignExpr (OP1 <<optInd assignExpr>>)*
assignExpr ::= orExpr (OP2 <<optInd orExpr>>)*
orExpr ::= andExpr (OP3 <<optInd andExpr>>)*
andExpr ::= cmpExpr (OP4 <<optInd cmpExpr>>)*
cmpExpr ::= sliceExpr (OP5 <<optInd sliceExpr>>)*
sliceExpr ::= ampExpr (OP6 <<optInd ampExpr>>)*
ampExpr ::= plusExpr (OP7 <<optInd plusExpr>>)*
plusExpr ::= mulExpr (OP8 <<optInd mulExpr>>)*
mulExpr ::= dollarExpr (OP9 <<optInd dollarExpr>>)*
dollarExpr ::= primary (OP10 <<optInd primary>>)*
symbol ::= '`' (KEYW|IDENT|literal|operator|'('|')'|'['|']'|'{'|'}'|'=')+ '`'|IDENT|KEYW
exprColonEqExpr ::= expr (':'|'=' expr)?
exprList ::= expr (',' expr)*
exprColonEqExprList2 ::= exprColonEqExpr (',' exprColonEqExpr)* ','?
qualifiedIdent ::= symbol ('.' <<optInd symbol>>)?
setOrTableConstr ::= '{' ((exprColonEqExpr ',')+ | ':') '}'
castExpr ::= 'cast' '[' <<optInd typeDesc>> <<optInd (']')>> '(' <<optInd expr>> <<optInd (')')>>
optPar ::=       (complexOrSimpleStmt (';' complexOrSimpleStmt)*)
            | (';' complexOrSimpleStmt (';' complexOrSimpleStmt)*)
            | pragmaStmt
            | (simpleExpr (('=' expr (';' complexOrSimpleStmt (';' complexOrSimpleStmt)*)?)
                         | (':' expr (',' exprColonEqExpr (',' exprColonEqExpr)*)?)))
par ::= '(' <<optInd optPar>> <<optInd (')')>>
literal ::= INT_LIT
          | INT8_LIT
          | INT16_LIT
          | INT32_LIT
          | INT64_LIT
          | UINT_LIT
          | UINT8_LIT
          | UINT16_LIT
          | UINT32_LIT
          | UINT64_LIT
          | FLOAT_LIT
          | FLOAT32_LIT
          | FLOAT64_LIT
          | STR_LIT
          | RSTR_LIT
          | TRIPLESTR_LIT
          | CHAR_LIT
          | NIL
generalizedLit ::= GENERALIZED_STR_LIT|GENERALIZED_TRIPLESTR_LIT
identOrLiteral ::= generalizedLit|symbol|literal|par|arrayConstr|setOrTableConstr|castExpr
arrayConstr ::= '[' <<optInd ((exprColonEqExpr ','?)*)>> <<optInd (']')>>
primarySuffix ::= ('(' <<optInd ((exprColonEqExpr ','?)*)>> ')')
                | ('.' <<optInd (symbol generalizedLit?)>>)
                | ('[' <<optInd exprColonEqExprList2>> <<optInd (']')>>)
                | ('{' <<optInd exprColonEqExprList2>> <<optInd ('}')>>)
                | <<optInd expr>> // command syntax
condExpr ::= expr ':' <<optInd expr>> ('elif' expr ':' <<optInd expr>>)* 'else' ':' expr
ifExpr ::= 'if' condExpr
whenExpr ::= 'when' condExpr
pragma ::= '{.' <<optInd ((exprColonEqExpr ','?)*)>> <<optInd ('.}'|'}')>>
identVis ::= symbol OPR? // postfix position
identVisDot ::= symbol '.' <<optInd symbol>> OPR?
identWithPragma ::= identVis pragma?
identWithPragmaDot ::= identVisDot pragma?
declColonEquals ::= identWithPragma (',' identWithPragma)* ','? (':' <<optInd typeDesc>>)? ('=' <<optInd expr>>)?
identColonEquals ::= IDENT (',' IDENT)* ','? (':' <<optInd typeDesc>>)? ('=' <<optInd expr>>)?
paramList ::= '(' (declColonEquals ((','|';') declColonEquals)*)? ')'
paramListArrow ::= paramList? ('->' <<optInd typeDesc>>)?
paramListColon ::= paramList? (':' <<optInd typeDesc>>)?
doBlock ::= 'do' paramListArrow pragma? ':' stmt
forStmt ::= 'for' (identWithPragma (',' identWithPragma)*) 'in' expr ':' stmt
expr ::= blockExpr|ifExpr|whenExpr|caseStmt|forStmt|tryExpr|simpleExpr
typeKeyw ::= 'var'|'out'|'ref'|'ptr'|'shared'|'tuple'|'proc'|'iterator'|'distinct'|'object'|'enum'
primary ::= (typeKeyw <<optInd typeDesc>>) | (operator* identOrLiteral primarySuffix*) | ('bind' primary)
typeDesc ::= simpleExpr ('not' expr)?
typeDefAux ::= simpleExpr ('not' expr)? | 'concept' typeClass
postExprBlocks ::= ':' stmt? ( (IND_EQ doBlock)
                             | (IND_EQ 'of' exprList ':' stmt)
                             | (IND_EQ 'elif' expr ':' stmt)
                             | (IND_EQ 'except' exprList ':' stmt)
                             | (IND_EQ 'else' ':' stmt) )*
exprStmt ::= simpleExpr (('=' <<optInd expr>> colonBody?) | (expr (',' expr)* postExprBlocks))?
importStmt ::= 'import' <<optInd expr>> ((',' expr)+ | ('except' <<optInd (expr (',' expr)*)>> ))
exportStmt ::= 'export' <<optInd expr>> ((',' expr)+ | ('except' <<optInd (expr (',' expr)*)>> ))
includeStmt ::= 'include' <<optInd expr>> (',' expr)*
fromStmt ::= 'from' expr 'import' <<optInd expr>> (',' expr)*
returnStmt ::= 'return' <<optInd expr>>?
raiseStmt ::= 'raise' <<optInd expr>>?
yieldStmt ::= 'yield' <<optInd expr>>?
discardStmt ::= 'discard' <<optInd expr>>?
breakStmt ::= 'break' <<optInd expr>>?
continueStmt ::= 'break' <<optInd expr>>?
condStmt ::= expr ':' stmt (IND_EQ 'elif' expr ':' stmt)* (IND_EQ 'else' ':' stmt)?
ifStmt ::= 'if' condStmt
whenStmt ::= 'when' condStmt
whileStmt ::= 'while' expr ':' stmt
ofBranch ::= 'of' exprList ':' stmt
ofBranches ::= ofBranch (IND_EQ ofBranch)* (IND_EQ 'elif' expr ':' stmt)* (IND_EQ 'else' ':' stmt)?
caseStmt ::= 'case' expr ':'? ((IND_GT ofBranches IND_LT) | (IND_EQ ofBranches))
tryStmt ::= 'try' ':' stmt (IND_EQ? 'except' exprList ':' stmt)* (IND_EQ? 'finally' ':' stmt)?
tryExpr ::= 'try' ':' stmt (<<optInd ('except' exprList ':' stmt)>> )* (<<optInd ('finally' ':' stmt)>>)?
blockStmt ::= 'block' symbol? ':' stmt
blockExpr ::= 'block' symbol? ':' stmt
staticStmt ::= 'static' ':' stmt
deferStmt ::= 'defer' ':' stmt
asmStmt ::= 'asm' pragma? (STR_LIT|RSTR_LIT|TRIPLESTR_LIT)
genericParam ::= symbol (',' symbol)* (':' expr)? ('=' <<optInd expr>>)?
genericParamList ::= '[' <<optInd ((genericParam ((','|';') genericParam)*)?)>> <<optInd (']')>>
pattern ::= '{' stmt '}'
routine ::= <<optInd (identVis pattern? genericParamList? paramListColon pragma? ('=' stmt)?)>>
private meta section ::= <<RULE>> | (IND_GT <<RULE>>? (IND_EQ <<RULE>>?)* IND_LT)
typeClassParam ::= ('var'|'out')? symbol
typeClass ::= (typeClassParam (',' typeClassParam)*)? pragma? ('of' (typeDesc (',' typeDesc)*)?)?
typeDef ::= identWithPragmaDot genericParamList? '=' <<optInd typeDefAux>>
            identVisDot genericParamList? pragma '=' <<optInd typeDefAux>>
varTuple ::= '(' <<optInd (identWithPragma (',' identWithPragma)*)>> <<optInd (')')>> '=' <<optInd expr>>
colonBody ::= ':' stmt postExprBlocks?
variable ::= (varTuple|identColonEquals) colonBody?
constant ::= (varTuple|identWithPragma) (':' typeDesc)? '=' <<optInd expr>>
bindStmt ::= 'bind' <<optInd (qualifiedIdent (',' qualifiedIdent)*)>>
mixinStmt ::= 'mixin' <<optInd (qualifiedIdent (',' qualifiedIdent)*)>>
pragmaStmt ::= pragma (':' stmt)?
simpleStmt ::= returnStmt
             | raiseStmt
             | yieldStmt
             | discardStmt
             | breakStmt
             | continueStmt
             | pragmaStmt
             | importStmt
             | exportStmt
             | fromStmt
             | includeStmt
             | exprStmt
complexOrSimpleStmt ::= ifStmt
                      | whenStmt
                      | whileStmt
                      | tryStmt
                      | forStmt
                      | blockStmt
                      | staticStmt
                      | deferStmt
                      | asmStmt
                      | 'proc' routine
                      | 'func' routine
                      | 'method' routine
                      | 'iterator' routine
                      | 'macro' routine
                      | 'template' routine
                      | 'converter' routine
                      | 'type' <<section typeDef>>
                      | 'const' <<section constant>>
                      | ('let'|'var'|'using') <<section variable>>
                      | bindStmt
                      | mixinStmt
                      | simpleStmt
stmt ::= (IND_GT complexOrSimpleStmt ((IND_EQ|';') complexOrSimpleStmt)* IND_LT) | simpleStmt
