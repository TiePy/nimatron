/*
 * This file is based on example provided by the IntelliJ Platform SDK DevGuide.
 * Copyright 2000-2020 JetBrains s.r.o. and other contributors.
 * Use of original example source code is governed by the Apache 2.0 license.
 *
 * Copyright 2020 TiePy Ltd. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This file is part of Nimatron, a Nim plug-in for IDEA platform IDEs.
 *
 * Nimatron is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.  TiePy Ltd designates this
 * particular file as subject to the "Classpath" exception as provided
 * by TiePy Ltd in the LICENSE file that accompanied this code.
 *
 * Nimatron is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Nimatron.  If not, see <https://www.gnu.org/licenses/>.
 *
 * Please contact TiePy Ltd, 19 Lyall Way, Laurencekirk, AB30 1FU, UK
 * or visit www.tiepy.com if you need additional information or have any
 * questions.
 */

{
  parserClass="com.tiepy.nimatron.parser.NimParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Nim"
  psiImplClassSuffix="Impl"
  psiPackage="com.tiepy.nimatron.parser"
  psiImplPackage="com.tiepy.nimatron.parser.impl"

  elementTypeHolderClass="com.tiepy.nimatron.parser.NimTypes"
  elementTypeClass="com.tiepy.nimatron.psi.NimElementType"
  tokenTypeClass="com.tiepy.nimatron.psi.NimTokenType"

  tokens = [
//    BRACKET="BRACKET"
//    SEMICOLON="SEMICOLON"
//    COMMA="COMMA"
//    GRAVE_ACCENT="GRAVE_ACCENT"

    BRACKET="BRACKET"
    COMMA="COMMA"
    GENERALIZED_STR_LIT="GENERALIZED_STR_LIT"
    GENERALIZED_TRIPLESTR_LIT="GENERALIZED_TRIPLESTR_LIT"
    GRAVE_ACCENT="GRAVE_ACCENT"
    KEYW="KEYW"
    OP0="OP0"
    OP1="OP1"
    OP10="OP10"
    OP2="OP2"
    OP3="OP3"
    OP4="OP4"
    OP5="OP5"
    OP6="OP6"
    OP7="OP7"
    OP8="OP8"
    OP9="OP9"
    OPR="OPR"
    SEMICOLON="SEMICOLON"
  ]

  psiImplUtilClass="com.tiepy.nimatron.parser.impl.NimPsiImplUtil"
}

//module = stmt ^* (';' / IND{=})
module ::= IND_EQ* stmts? ';'? IND_EQ*
private stmts ::= stmt ((';'|IND_EQ) stmt)*

//comma = ',' COMMENT?
//semicolon = ';' COMMENT?
//colon = ':' COMMENT?
//colcom = ':' COMMENT?

//operator =  OP0 | OP1 | OP2 | OP3 | OP4 | OP5 | OP6 | OP7 | OP8 | OP9
//         | 'or' | 'xor' | 'and'
//         | 'is' | 'isnot' | 'in' | 'notin' | 'of' | 'as' | 'from' |
//         | 'div' | 'mod' | 'shl' | 'shr' | 'not' | 'static' | '..'

//prefixOperator = operator

//optInd = COMMENT? IND?
private termInd ::= DEDENT | <<eof>>
private meta optInd ::= <<RULE>> | (INDENT <<RULE>> termInd)

//optPar = (IND{>} | IND{=})?

//simpleExpr = arrowExpr (OP0 optInd arrowExpr)* pragma?
//arrowExpr = assignExpr (OP1 optInd assignExpr)*
//assignExpr = orExpr (OP2 optInd orExpr)*
//orExpr = andExpr (OP3 optInd andExpr)*
//andExpr = cmpExpr (OP4 optInd cmpExpr)*
//cmpExpr = sliceExpr (OP5 optInd sliceExpr)*
//sliceExpr = ampExpr (OP6 optInd ampExpr)*
//ampExpr = plusExpr (OP7 optInd plusExpr)*
//plusExpr = mulExpr (OP8 optInd mulExpr)*
//mulExpr = dollarExpr (OP9 optInd dollarExpr)*
//dollarExpr = primary (OP10 optInd primary)*
simpleExpr ::= primary (OP5 <<optInd primary>>)* {pin=2}

//symbol = '`' (KEYW|IDENT|literal|(operator|'('|')'|'['|']'|'{'|'}'|'=')+)+ '`'
//       | IDENT | KEYW

//exprColonEqExpr = expr (':'|'=' expr)?
private exprColonEqExpr ::= expr (':'|'=' expr)?

//exprList = expr ^+ comma
exprList ::= expr (',' expr)*

//exprColonEqExprList = exprColonEqExpr (comma exprColonEqExpr)* (comma)?

//dotExpr = expr '.' optInd (symbol | '[:' exprList ']')

//explicitGenericInstantiation = '[:' exprList ']' ( '(' exprColonEqExpr ')' )?

//qualifiedIdent = symbol ('.' optInd symbol)?

//setOrTableConstr = '{' ((exprColonEqExpr comma)* | ':' ) '}'

//castExpr = 'cast' '[' optInd typeDesc optPar ']' '(' optInd expr optPar ')'

//parKeyw = 'discard' | 'include' | 'if' | 'while' | 'case' | 'try'
//        | 'finally' | 'except' | 'for' | 'block' | 'const' | 'let'
//        | 'when' | 'var' | 'mixin'

//par = '(' optInd
//          ( &parKeyw complexOrSimpleStmt ^+ ';'
//          | ';' complexOrSimpleStmt ^+ ';'
//          | pragmaStmt
//          | simpleExpr ( ('=' expr (';' complexOrSimpleStmt ^+ ';' )? )
//                       | (':' expr (',' exprColonEqExpr     ^+ ',' )? ) ) )
//          optPar ')'

//literal = | INT_LIT | INT8_LIT | INT16_LIT | INT32_LIT | INT64_LIT
//          | UINT_LIT | UINT8_LIT | UINT16_LIT | UINT32_LIT | UINT64_LIT
//          | FLOAT_LIT | FLOAT32_LIT | FLOAT64_LIT
//          | STR_LIT | RSTR_LIT | TRIPLESTR_LIT
//          | CHAR_LIT
//          | NIL
literal ::= INT_LIT | INT8_LIT | INT16_LIT | INT32_LIT | INT64_LIT
          | UINT_LIT | UINT8_LIT | UINT16_LIT | UINT32_LIT | UINT64_LIT
          | FLOAT_LIT | FLOAT32_LIT | FLOAT64_LIT
          | STR_LIT | RSTR_LIT | TRIPLESTR_LIT
          | CHAR_LIT
          | BOOL_LIT
          | NIL

//generalizedLit = GENERALIZED_STR_LIT | GENERALIZED_TRIPLESTR_LIT
generalizedLit ::= GENERALIZED_STR_LIT | GENERALIZED_TRIPLESTR_LIT

//identOrLiteral = generalizedLit | symbol | literal
//               | par | arrayConstr | setOrTableConstr
//               | castExpr
private identOrLiteral ::= generalizedLit | IDENT | literal

//tupleConstr = '(' optInd (exprColonEqExpr comma?)* optPar ')'

//arrayConstr = '[' optInd (exprColonEqExpr comma?)* optPar ']'

//primarySuffix = '(' (exprColonEqExpr comma?)* ')'
//      | '.' optInd symbol generalizedLit?
//      | '[' optInd exprColonEqExprList optPar ']'
//      | '{' optInd exprColonEqExprList optPar '}'
//      | &( '`'|IDENT|literal|'cast'|'addr'|'type') expr # command syntax
private primarySuffix ::= ('(' <<optInd ((exprColonEqExpr ','?)*)>> ')')
                             | <<optInd exprList>> // command syntax

//condExpr = expr colcom expr optInd
//        ('elif' expr colcom expr optInd)*
//         'else' colcom expr

//ifExpr = 'if' condExpr

//whenExpr = 'when' condExpr

//pragma = '{.' optInd (exprColonEqExpr comma?)* optPar ('.}' | '}')

//identVis = symbol OPR?  # postfix position

//identVisDot = symbol '.' optInd symbol OPR?

//identWithPragma = identVis pragma?

//identWithPragmaDot = identVisDot pragma?

//declColonEquals = identWithPragma (comma identWithPragma)* comma?
//                  (':' optInd typeDesc)? ('=' optInd expr)?

//identColonEquals = IDENT (comma IDENT)* comma?
//     (':' optInd typeDesc)? ('=' optInd expr)?)
private identColonEquals ::= IDENT (',' IDENT)* ','?
       ('=' <<optInd expr>>)?

//inlTupleDecl = 'tuple'
//    '[' optInd  (identColonEquals (comma/semicolon)?)*  optPar ']'

//extTupleDecl = 'tuple'
//    COMMENT? (IND{>} identColonEquals (IND{=} identColonEquals)*)?

//tupleClass = 'tuple'

//paramList = '(' declColonEquals ^* (comma/semicolon) ')'

//paramListArrow = paramList? ('->' optInd typeDesc)?

//paramListColon = paramList? (':' optInd typeDesc)?

//doBlock = 'do' paramListArrow pragma? colcom stmt

//procExpr = 'proc' paramListColon pragma? ('=' COMMENT? stmt)?

//distinct = 'distinct' optInd typeDesc

//forStmt = 'for' (identWithPragma ^+ comma) 'in' expr colcom stmt

//forExpr = forStmt

//expr = (blockExpr
//      | ifExpr
//      | whenExpr
//      | caseStmt
//      | forExpr
//      | tryExpr)
//      / simpleExpr
expr ::= simpleExpr

//typeKeyw = 'var' | 'out' | 'ref' | 'ptr' | 'shared' | 'tuple'
//         | 'proc' | 'iterator' | 'distinct' | 'object' | 'enum'

//primary = typeKeyw optInd typeDesc
//        /  prefixOperator* identOrLiteral primarySuffix*
//        / 'bind' primary
private primary ::= identOrLiteral primarySuffix*

//typeDesc = simpleExpr ('not' expr)?

//typeDefAux = simpleExpr ('not' expr)?
//           | 'concept' typeClass

//postExprBlocks = ':' stmt? ( IND{=} doBlock
//                           | IND{=} 'of' exprList ':' stmt
//                           | IND{=} 'elif' expr ':' stmt
//                           | IND{=} 'except' exprList ':' stmt
//                           | IND{=} 'else' ':' stmt )*

//exprStmt = simpleExpr
//         (( '=' optInd expr colonBody? )
//         / ( expr ^+ comma
//             postExprBlocks
//           ))?
exprStmt ::= simpleExpr
           (( '=' <<optInd (expr colonBody?)>>)
           | ( expr (',' expr)* ))?

//importStmt = 'import' optInd expr
//              ((comma expr)*
//              / 'except' optInd (expr ^+ comma))

//exportStmt = 'export' optInd expr
//              ((comma expr)*
//              / 'except' optInd (expr ^+ comma))

//includeStmt = 'include' optInd expr ^+ comma

//fromStmt = 'from' expr 'import' optInd expr (comma expr)*

//returnStmt = 'return' optInd expr?

//raiseStmt = 'raise' optInd expr?

//yieldStmt = 'yield' optInd expr?

//discardStmt = 'discard' optInd expr?

//breakStmt = 'break' optInd expr?

//continueStmt = 'break' optInd expr?

//condStmt = expr colcom stmt COMMENT?
//           (IND{=} 'elif' expr colcom stmt)*
//           (IND{=} 'else' colcom stmt)?
condStmt ::= expr ':' <<optInd stmts>>
             (IND_EQ 'elif' expr ':' <<optInd stmts>>)*
             (IND_EQ 'else' ':' <<optInd stmts>>)? {pin=2}

//ifStmt = 'if' condStmt
ifStmt ::= 'if' condStmt {pin=1}

//whenStmt = 'when' condStmt

//whileStmt = 'while' expr colcom stmt

//ofBranch = 'of' exprList colcom stmt

//ofBranches = ofBranch (IND{=} ofBranch)*
//                      (IND{=} 'elif' expr colcom stmt)*
//                      (IND{=} 'else' colcom stmt)?

//caseStmt = 'case' expr ':'? COMMENT?
//            (IND{>} ofBranches DED
//            | IND{=} ofBranches)

//tryStmt = 'try' colcom stmt &(IND{=}? 'except'|'finally')
//           (IND{=}? 'except' exprList colcom stmt)*
//           (IND{=}? 'finally' colcom stmt)?

//tryExpr = 'try' colcom stmt &(optInd 'except'|'finally')
//           (optInd 'except' exprList colcom stmt)*
//           (optInd 'finally' colcom stmt)?

//exceptBlock = 'except' colcom stmt

//blockStmt = 'block' symbol? colcom stmt

//blockExpr = 'block' symbol? colcom stmt

//staticStmt = 'static' colcom stmt

//deferStmt = 'defer' colcom stmt

//asmStmt = 'asm' pragma? (STR_LIT | RSTR_LIT | TRIPLESTR_LIT)

//genericParam = symbol (comma symbol)* (colon expr)? ('=' optInd expr)?

//genericParamList = '[' optInd
//  genericParam ^* (comma/semicolon) optPar ']'

//genericParamList = '[' optInd
//  genericParam ^* (comma/semicolon) optPar ']'

//pattern = '{' stmt '}'

//indAndComment = (IND{>} COMMENT)? | COMMENT?

//routine = optInd identVis pattern? genericParamList?
//  paramListColon pragma? ('=' COMMENT? stmt)? indAndComment

//commentStmt = COMMENT

//section(RULE) = COMMENT? RULE / (IND{>} (RULE / COMMENT)^+IND{=} DED)
private meta section ::= <<RULE>> | (INDENT <<RULE>>? (IND_EQ <<RULE>>?)* DEDENT)

//objectWhen = 'when' expr colcom objectPart COMMENT?
//            ('elif' expr colcom objectPart COMMENT?)*
//            ('else' colcom objectPart COMMENT?)?

//objectBranch = 'of' exprList colcom objectPart

//objectBranches = objectBranch (IND{=} objectBranch)*
//                      (IND{=} 'elif' expr colcom objectPart)*
//                      (IND{=} 'else' colcom objectPart)?

//objectCase = 'case' identWithPragma ':' typeDesc ':'? COMMENT?
//            (IND{>} objectBranches DED
//            | IND{=} objectBranches)

//objectPart = IND{>} objectPart^+IND{=} DED
//           / objectWhen / objectCase / 'nil' / 'discard' / declColonEquals

//object = 'object' pragma? ('of' typeDesc)? COMMENT? objectPart

//typeClassParam = ('var' | 'out')? symbol

//typeClass = typeClassParam ^* ',' (pragma)? ('of' typeDesc ^* ',')?
//              &IND{>} stmt

//typeDef = identWithPragmaDot genericParamList? '=' optInd typeDefAux
//            indAndComment? / identVisDot genericParamList? pragma '=' optInd typeDefAux
//            indAndComment?

//varTuple = '(' optInd identWithPragma ^+ comma optPar ')' '=' optInd expr

//colonBody = colcom stmt postExprBlocks?
private colonBody ::= ':' stmt

//variable = (varTuple / identColonEquals) colonBody? indAndComment
variable ::= identColonEquals colonBody?

//constant = (varTuple / identWithPragma) (colon typeDesc)? '=' optInd expr indAndComment

//bindStmt = 'bind' optInd qualifiedIdent ^+ comma

//mixinStmt = 'mixin' optInd qualifiedIdent ^+ comma

//pragmaStmt = pragma (':' COMMENT? stmt)?

//simpleStmt = ((returnStmt | raiseStmt | yieldStmt | discardStmt | breakStmt
//           | continueStmt | pragmaStmt | importStmt | exportStmt | fromStmt
//           | includeStmt | commentStmt) / exprStmt) COMMENT?
private simpleStmt::= exprStmt

//complexOrSimpleStmt = (ifStmt | whenStmt | whileStmt
//                    | tryStmt | forStmt
//                    | blockStmt | staticStmt | deferStmt | asmStmt
//                    | 'proc' routine
//                    | 'func' routine
//                    | 'method' routine
//                    | 'iterator' routine
//                    | 'macro' routine
//                    | 'template' routine
//                    | 'converter' routine
//                    | 'type' section(typeDef)
//                    | 'const' section(constant)
//                    | ('let' | 'var' | 'using') section(variable)
//                    | bindStmt | mixinStmt)
//                    / simpleStmt
private complexOrSimpleStmt ::= ifStmt
                              | varStmt
                              | simpleStmt
varStmt ::= (('let'|'var'|'using') <<section variable>>) {pin=1}

//stmt = (IND{>} complexOrSimpleStmt^+(IND{=} / ';') DED)
//     / simpleStmt ^+ ';'
stmt ::= complexOrSimpleStmt|simpleStmt

/*
module ::= IND_EQ* (stmt ((';'|IND_EQ) stmt)*)? ';'? IND_EQ*
private operator ::= OP0|OP1|OP2|OP3|OP4|OP5|OP6|OP7|OP8|OP9|'from'|'static'|'..'
private meta optInd ::= <<RULE>> | (INDENT <<RULE>> termInd)
private termInd ::= DEDENT | <<eof>>
private simpleExpr ::= arrowExpr (OP0 <<optInd arrowExpr>>)* pragma?
private arrowExpr ::= assignExpr (OP1 <<optInd assignExpr>>)*
private assignExpr ::= orExpr (OP2 <<optInd orExpr>>)*
private orExpr ::= andExpr (OP3 <<optInd andExpr>>)*
private andExpr ::= cmpExpr (OP4 <<optInd cmpExpr>>)*
private cmpExpr ::= sliceExpr (OP5 <<optInd sliceExpr>>)*
private sliceExpr ::= ampExpr (OP6 <<optInd ampExpr>>)*
private ampExpr ::= plusExpr (OP7 <<optInd plusExpr>>)*
private plusExpr ::= mulExpr (OP8 <<optInd mulExpr>>)*
private mulExpr ::= dollarExpr (OP9 <<optInd dollarExpr>>)*
private dollarExpr ::= primary (OP10 <<optInd primary>>)*
private symbol ::= '`' (KEYW|IDENT|literal|operator|'('|')'|'['|']'|'{'|'}'|'=')+ '`'|IDENT|KEYW
private exprColonEqExpr ::= expr (':'|'=' expr)?
private exprList ::= expr (',' expr)*
private exprColonEqExprList2 ::= exprColonEqExpr (',' exprColonEqExpr)* ','?
private qualifiedIdent ::= symbol ('.' <<optInd symbol>>)?
private setOrTableConstr ::= '{' ((exprColonEqExpr ',')+ | ':') '}'
private castExpr ::= 'cast' '[' <<optInd typeDesc>> <<optInd (']')>> '(' <<optInd expr>> <<optInd (')')>>
private optPar ::=        (complexOrSimpleStmt (';' complexOrSimpleStmt)*)
                    | (';' complexOrSimpleStmt (';' complexOrSimpleStmt)*)
                    | pragmaStmt
                    | (simpleExpr (('=' expr (';' complexOrSimpleStmt (';' complexOrSimpleStmt)*)?)
                                 | (':' expr (',' exprColonEqExpr (',' exprColonEqExpr)*)?)))
private par ::= '(' <<optInd optPar>> <<optInd (')')>>
private literal ::= INT_LIT
                  | INT8_LIT
                  | INT16_LIT
                  | INT32_LIT
                  | INT64_LIT
                  | UINT_LIT
                  | UINT8_LIT
                  | UINT16_LIT
                  | UINT32_LIT
                  | UINT64_LIT
                  | FLOAT_LIT
                  | FLOAT32_LIT
                  | FLOAT64_LIT
                  | STR_LIT
                  | RSTR_LIT
                  | TRIPLESTR_LIT
                  | CHAR_LIT
                  | NIL
private generalizedLit ::= GENERALIZED_STR_LIT|GENERALIZED_TRIPLESTR_LIT
private identOrLiteral ::= generalizedLit|symbol|literal|par|arrayConstr|setOrTableConstr|castExpr
private arrayConstr ::= '[' <<optInd ((exprColonEqExpr ','?)*)>> <<optInd (']')>>
private primarySuffix ::= ('(' <<optInd ((exprColonEqExpr ','?)*)>> ')')
                        | ('.' <<optInd (symbol generalizedLit?)>>)
                        | ('[' <<optInd exprColonEqExprList2>> <<optInd (']')>>)
                        | ('{' <<optInd exprColonEqExprList2>> <<optInd ('}')>>)
                        | <<optInd exprList>> // command syntax
private condExpr ::= expr ':' <<optInd expr>> ('elif' expr ':' <<optInd expr>>)* 'else' ':' expr
private ifExpr ::= 'if' condExpr
private whenExpr ::= 'when' condExpr
private pragma ::= '{.' <<optInd ((exprColonEqExpr ','?)*)>> <<optInd ('.}'|'}')>>
private identVis ::= symbol OPR? // postfix position
private identVisDot ::= symbol '.' <<optInd symbol>> OPR?
private identWithPragma ::= identVis pragma?
private identWithPragmaDot ::= identVisDot pragma?
private declColonEquals ::= identWithPragma (',' identWithPragma)* ','? (':' <<optInd typeDesc>>)? ('=' <<optInd expr>>)?
private identColonEquals ::= IDENT (',' IDENT)* ','? (':' <<optInd typeDesc>>)? ('=' <<optInd expr>>)?
private paramList ::= '(' (declColonEquals ((','|';') declColonEquals)*)? ')'
private paramListArrow ::= paramList? ('->' <<optInd typeDesc>>)?
private paramListColon ::= paramList? (':' <<optInd typeDesc>>)?
private doBlock ::= 'do' paramListArrow pragma? ':' stmt
private forStmt ::= 'for' (identWithPragma (',' identWithPragma)*) 'in' expr ':' stmt
expr ::= blockExpr|ifExpr|whenExpr|caseStmt|forStmt|tryExpr|simpleExpr
private typeKeyw ::= 'var'|'out'|'ref'|'ptr'|'shared'|'tuple'|'proc'|'iterator'|'distinct'|'object'|'enum'
primary ::= (typeKeyw <<optInd typeDesc>>) | (operator* identOrLiteral primarySuffix*) | ('bind' primary)
private typeDesc ::= simpleExpr ('not' expr)?
private typeDefAux ::= simpleExpr ('not' expr)? | 'concept' typeClass
private postExprBlocks ::= ':' stmt? ( (IND_EQ doBlock)
                                     | (IND_EQ 'of' exprList ':' stmt)
                                     | (IND_EQ 'elif' expr ':' stmt)
                                     | (IND_EQ 'except' exprList ':' stmt)
                                     | (IND_EQ 'else' ':' stmt) )*
private exprStmt ::= simpleExpr (('=' <<optInd expr>> colonBody?) | (expr (',' expr)* postExprBlocks))?
private importStmt ::= 'import' <<optInd expr>> ((',' expr)+ | ('except' <<optInd (expr (',' expr)*)>> ))
private exportStmt ::= 'export' <<optInd expr>> ((',' expr)+ | ('except' <<optInd (expr (',' expr)*)>> ))
private includeStmt ::= 'include' <<optInd expr>> (',' expr)*
private fromStmt ::= 'from' expr 'import' <<optInd expr>> (',' expr)*
private returnStmt ::= 'return' <<optInd expr>>?
private raiseStmt ::= 'raise' <<optInd expr>>?
private yieldStmt ::= 'yield' <<optInd expr>>?
private discardStmt ::= 'discard' <<optInd expr>>?
private breakStmt ::= 'break' <<optInd expr>>?
private continueStmt ::= 'break' <<optInd expr>>?
private condStmt ::= expr ':' stmt (IND_EQ 'elif' expr ':' stmt)* (IND_EQ 'else' ':' stmt)?
private ifStmt ::= 'if' condStmt
private whenStmt ::= 'when' condStmt
private whileStmt ::= 'while' expr ':' stmt
private ofBranch ::= 'of' exprList ':' stmt
private ofBranches ::= ofBranch (IND_EQ ofBranch)* (IND_EQ 'elif' expr ':' stmt)* (IND_EQ 'else' ':' stmt)?
private caseStmt ::= 'case' expr ':'? ((INDENT ofBranches DEDENT) | (IND_EQ ofBranches))
private tryStmt ::= 'try' ':' stmt (IND_EQ? 'except' exprList ':' stmt)* (IND_EQ? 'finally' ':' stmt)?
private tryExpr ::= 'try' ':' stmt (<<optInd ('except' exprList ':' stmt)>> )* (<<optInd ('finally' ':' stmt)>>)?
private blockStmt ::= 'block' symbol? ':' stmt
private blockExpr ::= 'block' symbol? ':' stmt
private staticStmt ::= 'static' ':' stmt
private deferStmt ::= 'defer' ':' stmt
private asmStmt ::= 'asm' pragma? (STR_LIT|RSTR_LIT|TRIPLESTR_LIT)
private genericParam ::= symbol (',' symbol)* (':' expr)? ('=' <<optInd expr>>)?
private genericParamList ::= '[' <<optInd ((genericParam ((','|';') genericParam)*)?)>> <<optInd (']')>>
private pattern ::= '{' stmt '}'
private routine ::= <<optInd (identVis pattern? genericParamList? paramListColon pragma? ('=' stmt)?)>>
private meta section ::= <<RULE>> | (INDENT <<RULE>>? (IND_EQ <<RULE>>?)* DEDENT)
private typeClassParam ::= ('var'|'out')? symbol
private typeClass ::= (typeClassParam (',' typeClassParam)*)? pragma? ('of' (typeDesc (',' typeDesc)*)?)?
private typeDef ::= identWithPragmaDot genericParamList? '=' <<optInd typeDefAux>>
                    identVisDot genericParamList? pragma '=' <<optInd typeDefAux>>
private varTuple ::= '(' <<optInd (identWithPragma (',' identWithPragma)*)>> <<optInd (')')>> '=' <<optInd expr>>
private colonBody ::= ':' stmt postExprBlocks?
variable ::= (varTuple|identColonEquals) colonBody?
constant ::= (varTuple|identWithPragma) (':' typeDesc)? '=' <<optInd expr>>
private bindStmt ::= 'bind' <<optInd (qualifiedIdent (',' qualifiedIdent)*)>>
private mixinStmt ::= 'mixin' <<optInd (qualifiedIdent (',' qualifiedIdent)*)>>
private pragmaStmt ::= pragma (':' stmt)?
private simpleStmt ::= returnStmt
                     | raiseStmt
                     | yieldStmt
                     | discardStmt
                     | breakStmt
                     | continueStmt
                     | pragmaStmt
                     | importStmt
                     | exportStmt
                     | fromStmt
                     | includeStmt
                     | exprStmt
private complexOrSimpleStmt ::= ifStmt
                              | whenStmt
                              | whileStmt
                              | tryStmt
                              | forStmt
                              | blockStmt
                              | staticStmt
                              | deferStmt
                              | asmStmt
                              | 'proc' routine
                              | 'func' routine
                              | 'method' routine
                              | 'iterator' routine
                              | 'macro' routine
                              | 'template' routine
                              | 'converter' routine
                              | 'type' <<section typeDef>>
                              | 'const' <<section constant>>
                              | ('let'|'var'|'using') <<section variable>>
                              | bindStmt
                              | mixinStmt
                              | simpleStmt
stmt ::= (INDENT complexOrSimpleStmt ((IND_EQ|';') complexOrSimpleStmt)* DEDENT) | simpleStmt
*/
